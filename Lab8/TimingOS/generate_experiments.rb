#! /usr/bin/ruby

#################################################################
#
# generate_experiments.rb
#
# Generate a series of C functions that each time a different 
# number of assembly language instructions.  The generated
# C functions are also placed into an array of function pointers
# so they can be iterated over.
#
# Users control the specific functions generated by editing the
# for loop 
#
# (C) 2016 Zachary Kurmas
#
#################################################################


#*****************************************************************
#
# Generate a C function that will time num_timed instructions.
# instruction_pool is an array of instructions that 
# will be used round-robin.
#
#*****************************************************************
def make_function(num_timed, instruction_pool)

  # The __asm__ macro is used to insert assembly instructions 
  # into C code.  Create one __asm__ macro for each assembly 
  # instruction to be timed.
  pool_size = instruction_pool.length
  asm_statements = (0..num_timed-1).map do |i|
    "__asm__ volatile(\"#{instruction_pool[i % pool_size]}\");\n      "
  end
  
  answer = {:name => "time_#{num_timed}_ops"}

  # Insert the function name and  __asm__ macros into the C function
  # (The ~ after the << allows us to indent the body of the multiline string.)
  answer[:body]=<<-HERE
    unsigned long long #{answer[:name]}() {
      register uint32_t start = my_rdtsc();

      #{asm_statements.join}
      register uint32_t stop = my_rdtsc();
      return stop - start;
    }
  HERE
  answer # return answer
end

#*****************************************************************
#
# The "main" body of the script
#
#*****************************************************************


#
# Generate the first part of the C file (the #includes and 
# a function to call rdtsc).
#

puts <<HERE
#include <stddef.h>
#include <stdint.h>

static __inline__ unsigned long long my_rdtsc(void)
{
  register unsigned long long int x;
   __asm__ volatile ("rdtsc" : "=A" (x));
  return x;
}


HERE


#
# Create a separate function for each value of n to be tested.
#

fn_ptrs = []

# TODO: edit the for loop below to generate the desired set of functions.
for i in (5..5000).step(25)
  puts 
  puts

  # TODO: edit the set of assembly instructions to iterate over.
  # The cross-compiler generates 32-bit binaries, so you only have access to
  # these registers:  %eax, %ebx, %ecx, %edx, %esi, %edi, %ebp, %esp
  # When choosing registers, check the resulting assembly code to be sure 
  # you aren't clobbering anything important (e.g., using %esp is probably a 
  # bad idea).
  #func = make_function(i, ["addl $1, %eax"])
  #func = make_function(i, ["addl $1, %eax", "addl $1, %ecx"])
  #func = make_function(i, ["addl $1, %eax", "addl $1, %ecx", "addl $1, %edx"])
  #func = make_function(i, ["addl $1, %eax", "addl $1, %ecx", "addl $1, %edx", "addl $1, %esi"])
  #func = make_function(i, ["addl $1, %eax", "addl $1, %ecx", "addl $1, %edx", "addl $1, %esi", "addl $1, %edi"])
  func = make_function(i, ["addl $1, %eax", "addl $1, %ecx", "addl $1, %edx", "addl $1, %esi", "addl $1, %edi", "addl $1, %ebx"])

  # remember the name of the function.
  fn_ptrs.push(func[:name]);

  # print the function
  puts(func[:body])

end

# To make it easer to run all the function, set up an array of function pointers

puts("    int num_functions = #{fn_ptrs.length};")
puts("    unsigned long long (*functions[#{fn_ptrs.length}])() = { #{fn_ptrs.join(', ')} };");
